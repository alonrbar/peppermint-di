{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\container.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\errors\\index.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\errors\\nestedError.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\errors\\resolveError.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\errors\\typeInferenceError.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\i.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\index.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\injectable.ts","C:\\Users\\Alon\\Documents\\devel\\peppermint-di\\src\\resolveOptions.ts","external \"reflect-metadata\""],"names":["emptyLogger","msg","Container","canReflect","_canReflect","undefined","Reflect","construct","e","constructor","logger","Map","register","key","type","validateKey","keyStr","getKeyString","factories","set","resolveCTor","Error","registerFactory","factory","registerSingle","value","potentialSingletons","singletons","registerSingleFactory","registerInitializer","initializer","initializersList","initializers","get","push","options","resolveSingleDependency","call","foo","thisArg","dependencies","resolveDependencies","apply","JSON","stringify","name","toString","Object","assign","ResolveOptions","params","fromParams","instance","resolveFactory","initializeInstance","singleton","singletonFactory","resolveSingletonFactory","constructUnregistered","optionalParameters","ResolveError","delete","ctor","MiddlemanCTor","prototype","func","args","getArgumentKeys","argKey","dependency","argNames","getArgumentNames","argTypes","getArgumentTypes","length","map","index","TypeInferenceError","argsStr","arg","FN_ARGS","CLASS_CTOR_ARGS","functionArgsRegex","match","classArgsRegex","split","str","trim","filter","getMetadata","NestedError","createStack","myStack","innerError","stack","message","setPrototypeOf","innerErr","i","interfaceSymbol","target","parameterName","parameterIndex","paramTypes","defineMetadata","injectable"],"mappings":"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","file":"peppermint-di.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"peppermint-di\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"peppermint-di\"] = factory();\n\telse\n\t\troot[\"peppermint-di\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import 'reflect-metadata';\r\nimport { ResolveError, TypeInferenceError } from './errors';\r\nimport { ResolveOptions } from './resolveOptions';\r\nimport { Constructor, ContainerKey, Factory, Initializer, SimpleContainerKey } from './types';\r\n\r\nfunction emptyLogger(msg: string) {\r\n    // noop\r\n}\r\n\r\n/**\r\n * A dependency injection container\r\n *\r\n * Based on: \r\n * https://stackoverflow.com/questions/20058391/javascript-dependency-injection\r\n * http://www.yusufaytas.com/dependency-injection-in-javascript/\r\n */\r\nexport class Container {\r\n\r\n    private static get canReflect(): boolean {\r\n        if (Container._canReflect === undefined) {\r\n            try {\r\n                Container._canReflect = (Reflect && Reflect.construct) ? true : false;\r\n            } catch (e) {\r\n                Container._canReflect = false;\r\n            }\r\n        }\r\n        return Container._canReflect;\r\n    }\r\n    private static _canReflect: boolean;\r\n\r\n    private readonly logger: (msg: string) => void;\r\n    private readonly factories = new Map<ContainerKey<any>, Factory<any>>();\r\n    private readonly initializers = new Map<ContainerKey<any>, Initializer<any>[]>();\r\n    private readonly potentialSingletons = new Map<ContainerKey<any>, Factory<any>>();\r\n    private readonly singletons = new Map<ContainerKey<any>, any>();\r\n\r\n    /**\r\n     * @param logger Optional logger method. E.g. console.log.\r\n     */\r\n    constructor(logger?: (msg: string) => void) {\r\n        this.logger = logger || emptyLogger;\r\n    }\r\n\r\n    // --- public methods --- //\r\n\r\n    /**\r\n     * Register a transient dependency.\r\n     * \r\n     * @param key The type to register.\r\n     * @param type Optional. Concrete type to return instead of the 'key' parameter.\r\n     */\r\n    public register<T>(key: Constructor<T>, type?: Constructor<T>): void;\r\n    /**\r\n     * Register a transient dependency.\r\n     * \r\n     * @param key String (for JavaScript) or symbol (for TypeScript interfaces).\r\n     * @param type The type to register.\r\n     */\r\n    public register<T>(key: SimpleContainerKey, type: Constructor<T>): void;\r\n    public register<T>(key: ContainerKey<T>, type?: Constructor<T>): void {\r\n        this.validateKey(key);\r\n\r\n        const keyStr = this.getKeyString(key);\r\n\r\n        // key is constructor\r\n        if ((type === null || type === undefined) && typeof key === 'function') {\r\n\r\n            this.logger(`Registering '${keyStr}' (${nameof(key)} as constructor)`);\r\n            this.factories.set(key, () => {\r\n                return this.resolveCTor(key, null);\r\n            });\r\n\r\n        } else if (type) {\r\n\r\n            if (typeof type !== 'function')\r\n                throw new Error(`Invalid argument '${nameof(type)}'. Constructor function expected.`);\r\n\r\n            // key is primitive or \"interface type\", type is concrete type\r\n            this.logger(`Registering '${keyStr}' (${nameof(type)} as constructor)`);\r\n            this.factories.set(key, () => {\r\n                return this.resolveCTor(type, null);\r\n            });\r\n\r\n        } else {\r\n            throw new Error(`Missing argument '${nameof(type)}'.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a transient dependency.\r\n     */\r\n    public registerFactory<T>(key: ContainerKey<T>, factory: Factory<T>): void {\r\n        this.validateKey(key);\r\n\r\n        if (typeof factory !== 'function')\r\n            throw new Error(`Invalid argument '${nameof(factory)}'. Factory function expected.`);\r\n\r\n        const keyStr = this.getKeyString(key);\r\n        this.logger(`Registering '${keyStr}' (factory callback)`);\r\n        this.factories.set(key, factory);\r\n    }\r\n\r\n    /**\r\n     * Register a singleton dependency.\r\n     *\r\n     * @param key The type to register.\r\n     * @param value Singleton object or a constructor function that will be\r\n     * called once and it's result will be cached and re-served.\r\n     */\r\n    public registerSingle<T>(key: Constructor<T>, value?: T | Constructor<T>): void;\r\n    /**\r\n     * Register a singleton dependency.\r\n     *\r\n     * @param key String (for JavaScript) or symbol (for TypeScript interfaces).\r\n     * @param value Singleton object or a constructor function that will be\r\n     * called once and it's result will be cached and re-served.\r\n     */\r\n    public registerSingle<T>(key: SimpleContainerKey, value: T | Constructor<T>): void;\r\n    public registerSingle<T>(key: ContainerKey<T>, value?: T | Constructor<T>): void {\r\n        this.validateKey(key);\r\n\r\n        const keyStr = this.getKeyString(key);\r\n\r\n        if ((value === null || value === undefined) && typeof key === 'function') {\r\n            this.logger(`Registering '${keyStr}' as singleton (${nameof(key)} as constructor)`);\r\n            this.potentialSingletons.set(key, () => {\r\n                return this.resolveCTor(key, null);\r\n            });\r\n\r\n        } else if (typeof value === 'object') {\r\n            this.logger(`Registering '${keyStr}' as singleton (value as instance)`);\r\n            this.singletons.set(key, value);\r\n\r\n        } else if (typeof value === 'function') {\r\n            this.logger(`Registering '${keyStr}' as singleton (value as constructor)`);\r\n            this.potentialSingletons.set(key, () => {\r\n                return this.resolveCTor(value as Constructor<T>, null);\r\n            });\r\n\r\n        } else {\r\n            throw new Error(`Invalid argument '${nameof(value)}'. Expected object or function.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a singleton dependency.\r\n     */\r\n    public registerSingleFactory<T>(key: ContainerKey<T>, factory: Factory<T>): void {\r\n        this.validateKey(key);\r\n\r\n        if (typeof factory !== 'function')\r\n            throw new Error(`Invalid argument '${nameof(factory)}'. Factory function expected.`);\r\n\r\n        const keyStr = this.getKeyString(key);\r\n        this.logger(`Registering '${keyStr}' as singleton (factory callback)`);\r\n        this.potentialSingletons.set(key, factory);\r\n    }\r\n\r\n    /**\r\n     * Register an initializer to be invoked each time a new instance of T is\r\n     * created by the container.\r\n     */\r\n    public registerInitializer<T>(key: ContainerKey<T>, initializer: Initializer<T>): void {\r\n        this.validateKey(key);\r\n\r\n        if (typeof initializer !== 'function')\r\n            throw new Error(`Invalid argument '${nameof(initializer)}'. Initializer function expected.`);\r\n\r\n        const keyStr = this.getKeyString(key);\r\n        this.logger(`Registering an initializer for '${keyStr}'`);\r\n\r\n        let initializersList = this.initializers.get(key);\r\n        if (!initializersList) {\r\n            initializersList = [];\r\n            this.initializers.set(key, initializersList);\r\n        }\r\n        initializersList.push(initializer);\r\n    }\r\n\r\n    /**\r\n     * Get an instance of T.\r\n     */\r\n    public get<T>(key: ContainerKey<T>, options?: ResolveOptions): T {\r\n        this.validateKey(key);\r\n        return this.resolveSingleDependency<T>(key, options);\r\n    }\r\n\r\n    /**\r\n     * Resolve function arguments and call it.\r\n     */\r\n    public call(foo: Function, thisArg?: any, options?: ResolveOptions): any {\r\n        const dependencies = this.resolveDependencies(foo, options);\r\n        return foo.apply(thisArg, dependencies);\r\n    }\r\n\r\n    // --- private methods --- //\r\n\r\n    private validateKey(key: ContainerKey<any>): void {\r\n        if (typeof key !== 'string' && typeof key !== 'function' && typeof key !== 'symbol')\r\n            throw new Error(`Invalid argument '${nameof(key)}'. Expected string, symbol or function. Received: ${JSON.stringify(key)}.`);\r\n    }\r\n\r\n    private getKeyString(key: ContainerKey<any>): string {\r\n        if (typeof key === 'string')\r\n            return key;\r\n        if (typeof key === 'function')\r\n            return key.name;\r\n        return key.toString();\r\n    }\r\n\r\n    /**\r\n     * resolve dependency using:\r\n     * 1. parameters supplied by caller\r\n     * 2. registered factories\r\n     * 3. registered singletons\r\n     * 4. construct\r\n     */\r\n    private resolveSingleDependency<T>(key: ContainerKey<T>, options: ResolveOptions): T {\r\n        const keyStr = this.getKeyString(key);\r\n        options = Object.assign(new ResolveOptions(), options || {});\r\n\r\n        // from params\r\n        if (options.params) {\r\n            const fromParams = options.params.get(key);\r\n            if (fromParams !== undefined) {\r\n                this.logger(`Resolving '${keyStr}' from params`);\r\n                return fromParams;\r\n            }\r\n        }\r\n\r\n        // from factories\r\n        const factory = this.factories.get(key);\r\n        if (factory !== undefined) {\r\n            this.logger(`Resolving '${keyStr}' from internal registry`);\r\n            const instance = this.resolveFactory(key, factory);\r\n            this.initializeInstance(key, instance);\r\n            return instance;\r\n        }\r\n\r\n        // from singletons\r\n        const singleton = this.singletons.get(key);\r\n        if (singleton !== undefined) {\r\n            this.logger(`Resolving '${keyStr}' from internal registry (singleton)`);\r\n            return singleton;\r\n        }\r\n\r\n        // from singleton factories\r\n        const singletonFactory = this.potentialSingletons.get(key);\r\n        if (singletonFactory !== undefined) {\r\n            this.logger(`Resolving '${keyStr}' from internal registry (singleton factory)`);\r\n            return this.resolveSingletonFactory(key, singletonFactory);\r\n        }\r\n\r\n        // dependency not registered...\r\n\r\n        // construct\r\n        if (options.constructUnregistered && typeof key === 'function') {\r\n            this.logger(`Resolving '${keyStr}' by invoking as constructor`);\r\n            const instance = this.resolveCTor(key, options);\r\n            this.initializeInstance(key, instance);\r\n            return instance;\r\n        }\r\n\r\n        // treat as optional parameter\r\n        if (options.optionalParameters) {\r\n            this.logger(`Resolving '${keyStr}' as optional parameter (undefined)`);\r\n            return undefined;\r\n        }\r\n\r\n        throw new ResolveError(keyStr, new Error('Dependency is not registered.'));\r\n    }\r\n\r\n    private resolveFactory<T>(key: ContainerKey<T>, factory: Factory<T>): T {\r\n        try {\r\n            return factory();\r\n        } catch (e) {\r\n            const keyStr = this.getKeyString(key);\r\n            throw new ResolveError(keyStr, e);\r\n        }\r\n    }\r\n\r\n    private resolveSingletonFactory<T>(key: ContainerKey<T>, singletonFactory: Factory<T>): T {\r\n        const keyStr = this.getKeyString(key);\r\n\r\n        // create the singleton\r\n        let singleton;\r\n        try {\r\n            singleton = singletonFactory();\r\n        } catch (e) {\r\n            throw new ResolveError(keyStr, e);\r\n        }\r\n\r\n        // initialize the singleton instance\r\n        this.initializeInstance(key, singleton);\r\n\r\n        // cache it\r\n        try {\r\n            this.singletons.set(key, singleton);\r\n        } catch (e) {\r\n            throw new ResolveError(keyStr, e);\r\n        }\r\n\r\n        // delete the singleton factory\r\n        this.potentialSingletons.delete(key);\r\n\r\n        return singleton;\r\n    }\r\n\r\n    private resolveCTor<T>(ctor: Constructor<T>, options: ResolveOptions): T {\r\n        const dependencies = this.resolveDependencies(ctor, options);\r\n\r\n        if (Container.canReflect) {\r\n            return Reflect.construct(ctor, dependencies);\r\n\r\n        } else {\r\n\r\n            // a workaround to allow calling a constructor through .apply\r\n            // see: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\r\n            const MiddlemanCTor = function (this: any) {\r\n                ctor.apply(this, dependencies);\r\n            };\r\n\r\n            MiddlemanCTor.prototype = ctor.prototype;\r\n\r\n            return new (MiddlemanCTor as any)();\r\n        }\r\n    }\r\n\r\n    private initializeInstance<T>(key: ContainerKey<T>, instance: T): void {\r\n        const initializersList = this.initializers.get(key);\r\n        if (!initializersList)\r\n            return;\r\n\r\n        for (const initializer of initializersList) {\r\n            initializer(instance);\r\n        }\r\n    }\r\n\r\n    private resolveDependencies(func: Function, options: ResolveOptions): any[] {\r\n        if (typeof func !== 'function')\r\n            throw new Error(`Invalid argument '${nameof(func)}'. Expected function.`);\r\n\r\n        const args = this.getArgumentKeys(func);\r\n\r\n        const dependencies: any[] = [];\r\n        for (const argKey of args) {\r\n\r\n            let dependency: any;\r\n            try {\r\n                dependency = this.resolveSingleDependency(argKey, options);\r\n            } catch (e) {\r\n                throw new ResolveError(func.name || '<anonymous>', e);\r\n            }\r\n\r\n            dependencies.push(dependency);\r\n        }\r\n        return dependencies;\r\n    }\r\n\r\n    private getArgumentKeys(func: Function): any[] {\r\n\r\n        const argNames = this.getArgumentNames(func);\r\n        const argTypes = this.getArgumentTypes(func);\r\n\r\n        // no type information\r\n        if (!argTypes || !argTypes.length)\r\n            return argNames;\r\n\r\n        // mismatch length - unknown error\r\n        if (argNames.length !== argTypes.length)\r\n            throw new Error('Failed reflecting function arguments.');\r\n\r\n        // fill missing type info by using argument name\r\n        const args = argTypes.map((type, index) => {\r\n\r\n            if (!type)\r\n                throw new TypeInferenceError(`Can not infer type of argument in index ${index} of the function '${func.name}'.`);\r\n\r\n            // primitives are never registered as dependency...\r\n            if (type.name !== 'Object' && type.name !== 'String')\r\n                return type;\r\n\r\n            return argNames[index];\r\n        });\r\n\r\n        // log\r\n        const argsStr = args.map(arg => {\r\n            if (typeof arg === 'function')\r\n                return arg.name;\r\n            return arg;\r\n        });\r\n        this.logger(`Arguments of '${func.name}': ${JSON.stringify(argsStr)}`);\r\n\r\n        // return\r\n        return args;\r\n    }\r\n\r\n    private getArgumentNames(func: Function): string[] {\r\n\r\n        // original regex from require.js\r\n        const FN_ARGS = /^function\\s*?[^\\(]*?\\(\\s*?([^\\)]*?)\\)/m;\r\n        const CLASS_CTOR_ARGS = /^class[\\s\\S]*?constructor\\s*?[^\\(]*?\\(\\s*?([^\\)]*?)\\)/m;\r\n\r\n        const functionArgsRegex = func.toString().match(FN_ARGS);\r\n        const classArgsRegex = func.toString().match(CLASS_CTOR_ARGS);\r\n\r\n        let args;\r\n        if (classArgsRegex && classArgsRegex.length) {\r\n            this.logger(`Function '${func.name}' declared as es5 class`);\r\n            args = classArgsRegex[1];\r\n        } else if (functionArgsRegex && functionArgsRegex.length) {\r\n            this.logger(`Function '${func.name}' declared as standard function`);\r\n            args = functionArgsRegex[1];\r\n        } else {\r\n            // Get here if:\r\n            // 1. It's a class declaration but no constructor was specified\r\n            // 2. Unknown parse error... Should improve the regex...\r\n            this.logger(`Could not detect arguments of '${func.name}'`);\r\n            return [];\r\n        }\r\n\r\n        args = args.split(',')\r\n            .map(str => str.trim())\r\n            .filter(arg => arg !== '');\r\n\r\n        return args;\r\n    }\r\n\r\n    private getArgumentTypes(func: Function): Function[] {\r\n\r\n        if (Container.canReflect) {\r\n\r\n            // https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\r\n            return Reflect.getMetadata('design:paramtypes', func);\r\n        }\r\n\r\n        return [];\r\n    }\r\n}","export * from './nestedError';\r\nexport * from './resolveError';\r\nexport * from './typeInferenceError';\r\n","/**\r\n * An Error that preserves inner Error's stack trace\r\n */\r\nexport class NestedError extends Error {\r\n\r\n    private static createStack(myStack: string, innerError?: Error): string {\r\n\r\n        if (!innerError)\r\n            return myStack;\r\n\r\n        myStack += '\\n------------------------------------------------\\n';\r\n        myStack += 'Inner Error: ';\r\n\r\n        if (innerError instanceof Error) {\r\n            myStack += innerError.stack;\r\n        } else {\r\n            myStack += (innerError as any).toString();\r\n        }\r\n\r\n        return myStack;\r\n    }\r\n\r\n    constructor(message: string, innerError?: Error) {\r\n        super(message);\r\n\r\n        this.stack = NestedError.createStack(this.stack, innerError);\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, NestedError.prototype);\r\n    }\r\n}","import { NestedError } from './nestedError';\r\n\r\nexport class ResolveError extends NestedError {\r\n\r\n    constructor(key: string, innerErr: Error) {\r\n        super(`Failed to resolve '${key}'.`, innerErr);\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, ResolveError.prototype);\r\n    }\r\n\r\n}","export class TypeInferenceError extends Error {\r\n    constructor(message?: string) {\r\n        super(message);\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, TypeInferenceError.prototype);\r\n    }\r\n}","import \"reflect-metadata\";\r\n\r\n/**\r\n * Declare the interface type of a parameter.\r\n *\r\n * Example:\r\n * \r\n * class MyClass {\r\n *    constructor(@i(IMyService) myService: IMyService) {\r\n *      ...\r\n *    }\r\n * }\r\n * \r\n * To see more about how or why it works read here:\r\n * https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\r\n */\r\nexport function i(interfaceSymbol: symbol): ParameterDecorator {\r\n    return (target: object, parameterName: string | symbol, parameterIndex: number) => {\r\n        const paramTypes = Reflect.getMetadata('design:paramtypes', target);\r\n        paramTypes[parameterIndex] = interfaceSymbol;\r\n        Reflect.defineMetadata('design:paramtypes', paramTypes, target);\r\n    };\r\n}","export * from './errors';\r\nexport * from './container';\r\nexport * from './i';\r\nexport * from './injectable';\r\nexport * from './resolveOptions';\r\nexport * from './types';\r\n","/**\r\n * Indicates that the decorated class can have it's constructor parameters injected.\r\n */\r\nexport function injectable(constructor: Function): void {\r\n    // no-op\r\n}","import { ContainerKey } from './types';\r\n\r\nexport class ResolveOptions {\r\n\r\n    /**\r\n     * If set to 'true' will treat unregistered dependencies as optional\r\n     * parameters and set their value to undefined.\r\n     * \r\n     * Default value: false\r\n     */\r\n    public optionalParameters?= false;\r\n\r\n    /**\r\n     * Set to 'false' if you don't want the injector to automatically try to\r\n     * construct unregistered constructors.\r\n     *\r\n     * Default value: true\r\n     */\r\n    public constructUnregistered?= true;\r\n\r\n    /**\r\n     * Parameters specified here will be used directly instead of being resolved.\r\n     */\r\n    public params?: Map<ContainerKey<any>, any>;\r\n}","module.exports = require(\"reflect-metadata\");"],"sourceRoot":""}